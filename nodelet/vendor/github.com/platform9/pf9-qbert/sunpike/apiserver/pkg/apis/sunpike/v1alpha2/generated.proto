/*
Copyright (C) 2015-2020 Platform9 Systems, Inc.
*/


// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = "proto2";

package github.com.platform9.pf9_qbert.sunpike.apiserver.pkg.apis.sunpike.v1alpha2;

import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/schema/generated.proto";

// Package-wide variables from generator "generated".
option go_package = "v1alpha2";

message AKSAgentPool {
  // Unique name of the agent pool profile in the context of the subscription and resource group
  optional string name = 1;

  // Number of agents (VMs) to host docker containers. Allowed values must be in the range of 0
  // to 100 (inclusive) for user pools and in the range of 1 to 100 (inclusive) for system pools.
  // The default value is 1
  optional int32 count = 2;

  // Size of agent VMs
  // +optional
  optional string vmSize = 3;

  // OS Disk Size in GB to be used to specify the disk size for every machine in this
  // master/agent pool. If you specify 0, it will apply the default osDisk size according
  // to the vmSize specified
  // +optional
  optional int32 osDiskSizeGB = 4;

  // OS disk type to be used for machines in a given agent pool. Allowed values are
  // 'Ephemeral' and 'Managed'. If unspecified, defaults to 'Ephemeral' when the VM
  // supports ephemeral OS and has a cache disk larger than the requested OSDiskSizeGB.
  // Otherwise, defaults to 'Managed'. May not be changed after creation
  // +optional
  optional string osDiskType = 5;

  // Maximum number of pods that can run on a node
  // +optional
  optional int32 maxPods = 6;

  // AgentPoolType represents types of an agent pool
  // +optional
  optional string type = 7;

  // Availability zones for nodes. Must use VirtualMachineScaleSets AgentPoolType
  // +optional
  repeated string availabilityZones = 8;

  // The current deployment or provisioning state, which only appears in the response
  optional string provisioningState = 9;

  // Describes whether the Agent Pool is Running or Stopped
  optional string powerState = 10;

  // Version of orchestrator specified when creating the managed cluster
  optional string kubernetesVersion = 11;

  // Agent pool node labels to be persisted across all nodes in agent pool
  // +optional
  map<string, string> labels = 12;

  // Represents mode of an agent pool
  // +optional
  optional string mode = 13;

  // OsType to be used to specify os type. Choose from Linux and Windows. Default to Linux
  // +optional
  optional string osType = 14;

  // NodeImageVersion is the version of node image
  // +optional
  optional string nodeImageVersion = 15;

  // VnetSubnetID of the agent pool
  // +optional
  optional string vnetSubnetID = 16;
}

// AKSCluster represents a managed AKS cluster
// More info: https://docs.microsoft.com/en-us/rest/api/aks/managedclusters/get#managedcluster
message AKSCluster {
  // Location explains the region in which the AKSCluster is present.
  optional string location = 1;

  // KubernetesVersion informs us about the kubernetes version on the cluster.
  optional string kubernetesVersion = 2;

  // Resource type
  optional string type = 3;

  // The current deployment or provisioning state, which only appears in the response.
  optional string provisioningState = 4;

  // Describes the Power State of the cluster
  optional string powerState = 5;

  // Whether to enable Kubernetes Role-Based Access Control
  // +optional
  optional bool enableRBAC = 6;

  // The max number of agent pools for the managed cluster
  // +optional
  optional int32 maxAgentPools = 7;

  // Name of the resource group containing agent pool nodes
  // +optional
  optional string nodeResourceGroup = 8;

  // Cluster network details
  // +optional
  optional AKSNetwork network = 9;

  // Array of agent pools associated with the cluster
  // +optional
  repeated AKSAgentPool agentPools = 10;

  // Array of Azure VM instances that make up the AKS cluster nodes
  // +optional
  repeated AKSInstance instances = 11;

  // ServicePrincipalClientID is the client id of the service principal associated with the cluster
  // +optional
  optional string servicePrincipalClientID = 12;

  // EnablePrivateCluster denotes whether a cluster is private, i.e. not accessible over the public network
  // +optional
  optional bool enablePrivateCluster = 13;

  // DNSPrefix is the prefix specified while creating the cluster
  // +optional
  optional string dnsPrefix = 14;

  // Tags is a map of all the resource tags associated with the cluster
  // +optional
  map<string, string> tags = 15;

  // FQDN is the cluster FQDN that can be used to connect with the K8s API server
  // +optional
  optional string fqdn = 16;
}

message AKSInstance {
  // Name of the instance
  optional string name = 1;

  // Location of the instance
  optional string location = 2;

  // ID or index of the instance
  optional string instanceId = 3;

  // This is the uniquie id for the instance
  optional string vmId = 4;

  // Array of zones
  repeated string zones = 5;

  // VM SKU
  optional AKSInstanceSKU sku = 6;

  // The virtual machine scale set of which the instance is a part of
  optional string virtualMachineScaleSetName = 7;

  // The agent pool of which the instance is a part of
  optional string agentPoolName = 8;

  // Tags associated with the instance
  // +optional
  map<string, string> tags = 9;

  // NetworkInterfaces attached to the instance
  // +optional
  repeated string networkInterfaces = 10;

  // OSProfile describes an instance OS profile like computer name, username, etc.
  // +optional
  optional AKSInstanceOSProfile osProfile = 11;
}

message AKSInstanceLinuxConfiguration {
  // SSHKeys specify the ssh key configurations for a Linux OS
  // +optional
  repeated AKSLinuxInstanceSSHKey sshKeys = 1;

  // DisablePasswordAuthentication specifies whether password authentication should be disabled
  // +optional
  optional bool disablePasswordAuthentication = 2;

  // ProvisionVMAgent indicates whether virtual machine agent should be provisioned on the virtual machine
  // +optional
  optional bool provisionVMAgent = 3;
}

message AKSInstanceOSProfile {
  // ComputerName is the host OS name of the virtual machine This name cannot be updated after
  // the VM is created. Max-length (Windows): 15 characters. Max-length (Linux): 64 characters.
  // +optional
  optional string computerName = 1;

  // AdminUsername is the name of the administrator account. This property cannot be updated
  // after the VM is created.
  // +optional
  optional string adminUsername = 2;

  // LinuxConfiguration is the Linux operating system settings on the virtual machine
  // +optional
  optional AKSInstanceLinuxConfiguration linuxConfiguration = 3;

  // WindowsConfiguration is the Windows operating system settings on the virtual machine
  // +optional
  optional AKSInstanceWindowsConfiguration windowsConfiguration = 4;
}

message AKSInstanceSKU {
  // Name of the SKU
  // +optional
  optional string name = 1;

  // Tier of the SKU i.e. Standard, etc.
  // +optional
  optional string tier = 2;
}

message AKSInstanceWindowsConfiguration {
  // WinRMListeners is the list of Windows Remote Management listeners
  // +optional
  repeated AKSWindowsInstanceWinRMListener winRMListeners = 1;

  // EnableAutomaticUpdates indicates whether Automatic Updates is enabled for the
  // Windows virtual machine. Default value is true
  // +optional
  optional bool enableAutomaticUpdates = 2;

  // ProvisionVMAgent indicates whether virtual machine agent should be provisioned on the virtual machine.
  // +optional
  optional bool provisionVMAgent = 3;

  // TimeZone specifies the time zone of the virtual machine. e.g. "Pacific Standard Time"
  // +optional
  optional string timeZone = 4;
}

message AKSLinuxInstanceSSHKey {
  // KeyData is the SSH public key certificate used to authenticate with the VM through ssh.
  // The key needs to be at least 2048-bit and in ssh-rsa format.
  // +optional
  optional string keyData = 1;

  // Path is the full path on the created VM where ssh public key is stored. If the file already exists,
  // the specified key is appended to the file. Example: /home/user/.ssh/authorized_keys
  // +optional
  optional string path = 2;
}

message AKSLoadBalancerProfile {
  // AllocatedOutboundPorts is the desired number of allocated SNAT ports per VM. Allowed values must be in the range of 0 to 64000 (inclusive). The default value is 0 which results in Azure dynamically allocating ports.
  // +optional
  optional int32 AllocatedOutboundPorts = 1;

  // ManagedOutboundIPs are the desired managed outbound IPs for the cluster load balancer
  // +optional
  optional int32 managedOutboundIPs = 2;

  // EffectiveOutboundIPs are the effective outbound IP resources of the cluster load balancer
  // +optional
  repeated string effectiveOutboundIPs = 3;

  // OutboundIPs are the desired outbound IP resources for the cluster load balancer
  // +optional
  repeated string outboundIPs = 4;

  // OutboundIPPrefixes are the desired outbound IP Prefix resources for the cluster load balancer
  // +optional
  repeated string outboundIPPrefixes = 5;
}

message AKSNetwork {
  // Network plugin used for building Kubernetes network
  // +optional
  optional string plugin = 1;

  // Network policy used for building Kubernetes network
  // +optional
  optional string policy = 2;

  // A CIDR notation IP range from which to assign service cluster IPs. It must not overlap with any Subnet IP ranges
  // +optional
  optional string serviceCIDR = 3;

  // A CIDR notation IP range assigned to the Docker bridge network
  // +optional
  optional string containerCIDR = 4;

  // An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes service
  // address range specified in serviceCidr
  // +optional
  optional string dnsServiceIP = 5;

  // The outbound (egress) routing method
  // +optional
  optional string outboundType = 6;

  // LoadBalancerSKU is the load balance SKU for the cluster
  // +optional
  optional string loadBalancerSKU = 7;

  // LoadBalancerProfile is the profile of the managed cluster load balancer
  // +optional
  optional AKSLoadBalancerProfile loadBalancerProfile = 8;
}

message AKSWindowsInstanceWinRMListener {
  // +optional
  optional string certificateURL = 1;

  // +optional
  optional string protocol = 2;
}

// APIEndpoint represents a reachable Kubernetes API endpoint.
message APIEndpoint {
  // Host is the hostname on which the kube-apiserver should be serving.
  //
  // If the Host is left empty, a hostname will be generated.
  optional string host = 1;

  // Port specifies on which the kube-apiserver should be serving.
  optional int32 port = 2;

  // UsePF9Domain indicates whether a the domain should be generated using a
  // platform9-managed domain. If it is set to false, a domain will be
  // generated specific to the cloud provider. For instance, in case of an AWS
  // cluster the domain name would be that of the ELB.
  //
  // If Host is not empty, this field will be ignored.
  // future(erwin): turn into enum?
  optional bool usePF9Domain = 3;
}

message AWSCloudProviderCredentials {
  // AccessKeyID is the access key ID of the user that should be used for
  // this cloud provider.
  //
  // More info: https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html
  optional string accessKeyID = 1;

  // SecretAccessKey is the secret access key associated with the access key ID.
  //
  // More info: https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html
  optional string secretAccessKey = 2;

  // Region can contain a AWS region which should be used by default for
  // new resources.
  optional string region = 3;
}

// AWSCloudProviderSpec contains all AWS-specific configuration for a CloudProvider.
message AWSCloudProviderSpec {
  // SecretName contains a reference to the secret in the same namespace in
  // which the AWS credentials are stored.
  //
  // The referenced secret should contains the following fields in its data:
  // (1) accessKeyID: the access key ID of the user that should be used for this cloud provider.
  // (2) secretAccessKey: the secret access key associated with the access key ID.
  // (3) region: an AWS region which should be used by default for new resources.
  //
  // More info: https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html
  optional string secretName = 1;

  // Region can contain a AWS region which should be used by default for
  // new resources. If non-empty, it overrides any region set in the secret.
  optional string region = 2;
}

// AWSCluster contains all AWS-specific configuration for the cluster
message AWSCluster {
  // SSHKeyName is the name of the ssh key to attach to the Hosts.
  // +optional
  optional string sshKeyName = 1;

  // Region contains the AWS Region the cluster lives in.
  optional string region = 2;

  // AZs specifies the Availablity Zones that the Cluster lives in.
  repeated string azs = 3;

  // AMI is the reference to the AMI from which to create the Hosts.
  // +optional
  optional string ami = 4;

  // MasterFlavor is the type of instance to use to create master Hosts.
  // Example: m4.xlarge
  optional string masterFlavor = 5;

  // WorkerFlavor is the type of instance to use to create worker Hosts.
  // Example: m4.xlarge
  optional string workerFlavor = 6;
}

// AWSOpts are options for the AWS VPC-CNI plugin.
//
// See more: https://github.com/aws/amazon-vpc-cni-k8s/blob/af55286bb5429a06841d2940597410dcc4e74d7e/README.md
message AWSOpts {
  // Specifies whether an external NAT gateway should be used to provide SNAT of
  // secondary ENI IP addresses.
  //
  // Corresponds to the AWS_VPC_CNI_EXTERNALSNAT environment variable in aws.
  optional bool externalSNAT = 1;
}

// AWSScalingConfig provides information regarding
// scaling of the nodegroup
// MoreInfo: https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-capacity-limits.html
message AWSScalingConfig {
  // +optional
  optional int32 minSize = 1;

  // +optional
  optional int32 maxSize = 2;

  // +optional
  optional int32 desiredSize = 3;
}

// AWSVPC provides information about the AWSVPC
// More info: https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html
message AWSVPC {
  optional string vpcId = 1;

  // +optional
  repeated string securityGroup = 2;

  // +optional
  optional bool publicAccess = 3;

  // +optional
  optional bool privateAccess = 4;

  // +optional
  optional string clusterSecurityGroupId = 5;

  // +optional
  repeated string subnets = 6;
}

// AddonOperatorOpts contains configuration related to platform9 addon operator
message AddonOperatorOpts {
  // taf of addon operator image tag if configured should be used for addon operator configuration on the cluster.
  optional string imageTag = 1;
}

// AddonOperatorVersion is a representation of a supported add on version for kube versions.
message AddonOperatorVersion {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta typeMeta = 1;

  // Standard object's metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 2;

  // KubeVersion is the Kubernetes-portion of the Version  as x.y.z
  // Example: 1.21.3
  optional string kubeVersion = 3;

  // Addons contains addon name and supported versions for given kube version
  repeated string versions = 4;
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message AddonOperatorVersionList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta typeMeta = 1;

  // Standard object's metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 2;

  repeated AddonOperatorVersion items = 3;
}

// AddonVersions contains supported addon versions
message AddonTypeVersion {
  // Name is the name of the Addon.
  optional string name = 1;

  // Versions contains the supported version list of the Addon.
  repeated string versions = 2;
}

// AddonVersion is a representation of a supported add on version for kube versions.
message AddonVersion {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta typeMeta = 1;

  // Standard object's metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 2;

  // KubeVersion is the Kubernetes-portion of the Version.
  // Example: 1.18, 1.19, 1.20, 1.21
  optional string kubeVersion = 3;

  // Addons contains addon name and supported versions for given kube version
  repeated AddonTypeVersion addons = 4;
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message AddonVersionList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta typeMeta = 1;

  // Standard object's metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 2;

  repeated AddonVersion items = 3;
}

// AddonsOpts is an aggregation of all supported addons.
message AddonsOpts {
  // AppCatalog specifies if and how the App Catalog addon should be
  // installed in the cluster.
  optional AppCatalogOpts appCatalog = 1;

  // CAS specifies if and how the Cluster AutoScaler addon should be
  // deployed in the cluster.
  optional ClusterAutoScalerOpts cas = 2;

  // Luigi contains the settings for the Luigi addons, if enabled.
  optional LuigiOpts luigi = 3;

  // Kubevirt specifies if and how the KubeVirt addon should be
  // installed in the cluster.
  optional KubeVirtOpts kubevirt = 4;

  // CPUManager defines the options used to manage the CPU and topology
  // manager feature.
  optional CPUManagerOpts cpuManager = 5;

  // ProfileAgent defines the options used to manage and configure the platform9 profile engine agent on the clsuter
  optional ProfileAgentOpts profileAgent = 6;

  // AddonOperator defines the options used to manage and configure platform9 addon-operator on the cluster
  optional AddonOperatorOpts addonOperator = 7;
}

// AppCatalogOpts contain configuration for the App Catalog addon.
message AppCatalogOpts {
  // Enabled signals that AppCatalog should be installed on the cluster, if set.
  optional bool enabled = 1;
}

message Auth {
  // Keystone is the container for all settings related to authentication with
  // the OpenStack Keystone identity service.
  //
  // More info: https://docs.openstack.org/keystone/latest/
  optional KeystoneOpts keystone = 1;
}

message AzureCloudProviderCredentials {
  // ClientID is the unique identifier of the Azure user account.
  optional string clientID = 1;

  // ClientSecret is the secret access key associated with the client ID.
  optional string clientSecret = 2;

  // SubscriptionID is a unique alphanumeric string that identifies your Azure subscription.
  optional string subscriptionID = 3;

  // TenantID contains the tenant identifier.
  optional string tenantID = 4;
}

// AzureCloudProviderSpec contains all Azure-specific configuration for a CloudProvider.
message AzureCloudProviderSpec {
  optional string secretName = 1;
}

// CNIOpts contains the CNI configuration, which includes general options,
// as well as, CNI-specific settings. Current supported CNI plugins are Calico,
// and Flannel, one of which should be non-empty based on the NetworkPlugin
// field (calico or flannel, respectively).
message CNIOpts {
  // Bridge specifies the CNI bridge to use.
  // Note(erwin): this seems to be used only for flannel.
  optional string bridge = 1;

  // MTUSize configures the MTU to use for workload interfaces and the tunnels.
  // Note(erwin): this seems to be used only for calico.
  optional int32 MTUSize = 2;

  // IPv6 indicates whether this cluster should support IPv6.
  // Note(erwin): this seems to be used only for calico.
  optional bool IPv6 = 3;

  // NetworkPlugin specifies the CNI plugin to use for this cluster. The
  // options are: calico or flannel. Based on this setting either the Calico
  // field should be filled, or the Flannel field should be filled.
  optional string networkPlugin = 4;

  // Calico contains options specific to the Calico CNI plugin.
  optional CalicoOpts calico = 5;

  // Flannel contains options specific to the Flannel CNI plugin.
  //
  // More info: https://github.com/coreos/flannel/blob/master/Documentation/configuration.md
  optional FlannelOpts flannel = 6;

  // AWSOpts are options for the AWS VPC-CNI plugin.
  //
  // See more: https://github.com/aws/amazon-vpc-cni-k8s/blob/af55286bb5429a06841d2940597410dcc4e74d7e/README.md
  optional AWSOpts aws = 7;
}

// CPUManagerOpts defines the options used to manage the CPU and topology manager feature
message CPUManagerOpts {
  optional string cpuManagerPolicy = 1;

  optional string topologyManagerPolicy = 2;

  optional string reservedCPUs = 3;
}

// CalicoOpts are options for the Calico CNI plugin.
//
// More info: https://docs.projectcalico.org/reference/node/configuration
message CalicoOpts {
  // IPIPMode is the IPIP Mode to use for the IPv4 POOL created at start up.
  // Options: Always, CrossSubnet, Never (“Off” is also accepted as a synonym for “Never”)
  //
  // Corresponds to the CALICO_IPV4POOL_IPIP environment variable in Calico.
  optional string IPIPMode = 1;

  // IPv4BlkSize is the block size to use for the IPv4 POOL created at
  // startup. Block size for IPv4 should be in the range 20-32 (inclusive).
  //
  // Corresponds to the CALICO_IPV4POOL_BLOCK_SIZE environment variable in Calico.
  optional int32 IPv4BlkSize = 2;

  // NatOutgoing controls whether the NAT Outgoing for the IPv4 Pool should
  // be created at start up.
  //
  // Corresponds to the CALICO_IPV4POOL_NAT_OUTGOING environment variable in Calico.
  optional bool NatOutgoing = 3;

  // IPv4Mode is the IPv4 address to assign this host or detection behavior
  // at startup. For the details of the behavior possible with this field,
  // see: https://docs.projectcalico.org/reference/node/configuration#ip-setting
  //
  // Corresponds to the IP environment variable in Calico.
  optional string IPv4Mode = 4;

  // IPv4DetectionMethod specifies the method to use to autodetect the IPv4
  // address for this host. This is only used when the IPv4 address is being
  // autodetected. For details of the valid methods, see:
  // https://docs.projectcalico.org/reference/node/configuration#ip-autodetection-methods
  //
  // Corresponds to the IP_AUTODETECTION_METHOD environment variable in Calico.
  optional string IPv4DetectionMethod = 5;

  // IPv6Mode is the IPv6 address to assign this host or detection behavior
  // at startup. For the details of the behavior possible with this field,
  // see: https://docs.projectcalico.org/reference/node/configuration#ip-setting
  //
  // Corresponds to the IP6 environment variable in Calico.
  optional string IPv6Mode = 6;

  // IPv6BlkSize is the block size to use for the IPv6 POOL created at
  // startup. Block size for IPv6 should be in the range 116-128 (inclusive).
  //
  // Corresponds to the CALICO_IPV6POOL_BLOCK_SIZE environment variable in Calico.
  optional int32 IPv6BlkSize = 7;

  // IPv6PoolCIDR specifies the IPv6 Pool to create if none exists at start-up.
  //
  // Corresponds to the CALICO_IPV6POOL_CIDR environment variable in Calico.
  optional string IPv6PoolCIDR = 8;

  // IPv6PoolNAT controls whether NAT Outgoing for the IPv6 Pool should be
  // created at start up.
  //
  // Corresponds to the CALICO_IPV6POOL_NAT_OUTGOING environment variable in Calico.
  optional bool IPv6PoolNAT = 9;

  // IPv6DetectionMethod specifies the method to use to autodetect the IPv4
  // address for this host. This is only used when the IPv6 address is being
  // autodetected. For details of the valid methods, see:
  // https://docs.projectcalico.org/reference/node/configuration#ip-autodetection-methods
  //
  // Corresponds to the IP6_AUTODETECTION_METHOD environment variable in Calico.
  optional string IPv6DetectionMethod = 10;

  // RouterID sets the router id to use for BGP if no IPv4 address is set on
  // the node. For an IPv6-only system, this may be set to hash. It then uses
  // the hash of the nodename to create a 4 byte router id.
  //
  // Corresponds to the CALICO_ROUTER_ID environment variable in Calico.
  optional string routerID = 11;

  // FelixIPv6Support enables Calico networking and security for IPv6 traffic
  // as well as for IPv4.
  //
  // More info: https://docs.projectcalico.org/reference/felix/configuration
  optional bool felixIPv6Support = 12;

  // Corresponds to the CALICO_NODE_CPU_LIMIT environment variable in Calico.
  optional string nodeCpuLimit = 13;

  // Corresponds to the CALICO_NODE_MEMORY_LIMIT environment variable in Calico.
  optional string nodeMemoryLimit = 14;

  // Corresponds to the CALICO_TYPHA_CPU_LIMIT environment variable in Calico.
  optional string typhaCpuLimit = 15;

  // Corresponds to the CALICO_TYPHA_MEMORY_LIMIT environment variable in Calico.
  optional string typhaMemoryLimit = 16;

  // Corresponds to the CALICO_CONTROLLER_CPU_LIMIT environment variable in Calico.
  optional string controllerCpuLimit = 17;

  // Corresponds to the CALICO_CONTROLLER_MEMORY_LIMIT environment variable in Calico.
  optional string controllerMemoryLimit = 18;
}

// CloudProvider is a representation of an infrastructure provider, which is used
// to initialize Hosts and/or Clusters.
message CloudProvider {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta typeMeta = 4;

  // Standard object's metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  // Specification of the desired behavior of the CloudProvider.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional CloudProviderSpec spec = 2;

  // Most recently observed status of the CloudProvider.
  // This data may not be up to date.
  // Populated by the system.
  // Read-only.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional CloudProviderStatus status = 3;
}

// CloudProviderList is a list of CloudProvider objects.
message CloudProviderList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta typeMeta = 3;

  // Standard list metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  // Items contains a list of Providers.
  repeated CloudProvider items = 2;
}

// CloudProviderSpec contains the specification of the desired configuration of the CloudProvider.
message CloudProviderSpec {
  // AWS contains all AWS-specific configuration for a CloudProvider.
  //
  // Any cluster-specific configuration goes into its type.
  // Only one of these should be non-nil.
  // +optional
  optional AWSCloudProviderSpec aws = 2;

  // Azure contains all Azure-specific configuration for a CloudProvider.
  //
  // Any cluster-specific configuration goes into its type.
  // Only one of these should be non-nil.
  // +optional
  optional AzureCloudProviderSpec azure = 3;

  // GCP contains all Google Cloud-specific configuration for a CloudProvider.
  //
  // Any cluster-specific configuration goes into its type.
  // Only one of these should be non-nil.
  // +optional
  optional GoogleCloudProviderSpec gke = 5;

  // Local contains all configuration specific to a on-premise CloudProvider.
  //
  // Any cluster-specific configuration goes into its type.
  // Only one of these should be non-nil.
  // +optional
  optional LocalCloudProviderSpec local = 4;
}

// CloudProviderStatus represents information about the status of a CloudProvider.
message CloudProviderStatus {
  // Phase describes the current phase of the CloudProvider.
  optional string phase = 1;

  // Type describes the controller-observed type of the CloudProvider. This is
  // based on what subfields are set in the CloudProviderSpec.
  // +optional
  optional string type = 2;

  // Conditions defines current service state of the CloudProvider.
  // +optional
  repeated Condition conditions = 3;

  // ObservedGeneration is the latest generation observed by the controller.
  // +optional
  optional int64 observedGeneration = 4;

  // Regions contains discovered and available regions in the cloudprovider.
  // +optional
  repeated Region regions = 5;

  // LastChecked specifies the last time that the accessibility to AWS was checked.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastChecked = 6;
}

// Cluster is a representation of the configuration and status of a Kubernetes cluster.
message Cluster {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta typeMeta = 4;

  // Standard object's metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  // Specification of the desired behavior of the Cluster.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional ClusterSpec spec = 2;

  // Most recently observed status of the Cluster.
  // This data may not be up to date.
  // Populated by the system.
  // Read-only.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional ClusterStatus status = 3;
}

// ClusterAddon is a list of all addons to be installed on a cluster
message ClusterAddon {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta typeMeta = 1;

  // Standard object's metadata.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 2;

  // Specification of the desired behavior of the Addon
  optional ClusterAddonSpec spec = 3;

  // Most recently observed status of the Addon
  optional ClusterAddonStatus status = 4;
}

// ClusterAddonList is a list of Addons objects.
message ClusterAddonList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta typeMeta = 1;

  // Standard list metadata
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 2;

  // Items contains a list of Addons
  repeated ClusterAddon items = 3;
}

// ClusterAddonSpec contains the specification of the desired behavior of the Addon.
message ClusterAddonSpec {
  // +optional
  // ClusterID
  optional string clusterID = 1;

  // Version of the Addon
  optional string version = 2;

  // Type of addon, should be one supported by the operator
  optional string type = 3;

  // Override is optional override params for the addon
  // +optional
  optional Override override = 4;

  // Watch resources deployed by the Addon and not allow manual changes
  // +optional
  optional bool watch = 5;

  // If specified, the addon pod's tolerations.
  // +optional
  repeated Toleration tolerations = 6;
}

// ClusterAddonStatus represents information about the status of a Addon. Status may
message ClusterAddonStatus {
  // Phase represents the current phase of addon.
  // E.g. Installing, Uninstalling, Installed Successfully etc.
  // +optional
  optional string phase = 1;

  // Message is a human-readable string that summarizes why the Addon is in this phase.
  // +optional
  optional string message = 4;

  // Healthy is true if the Addon is installed and healthy
  // +optional
  optional bool healthy = 2;

  // LastChecked specifies the last time that the Addon object on the Cluster was checked
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastChecked = 3;
}

// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message ClusterAgent {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta typeMeta = 1;

  // Standard object's metadata.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 2;

  optional ClusterAgentSpec spec = 3;

  // Current phase of the agent.
  // Valid values - connected, offline, errored
  // +optional
  optional ClusterAgentStatus status = 4;
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message ClusterAgentList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta typeMeta = 1;

  // Standard object's metadata.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 2;

  // Items contains the list of cluster profiles
  repeated ClusterAgent items = 3;
}

message ClusterAgentSpec {
  // ClusterName represents the identifier of the cluster for which
  // this ClusterAgent is intended.
  optional string clusterName = 1;
}

message ClusterAgentStatus {
  // Current phase of the cluster agent.
  // Enum of - connected, offline, errored
  optional string phase = 1;

  // Message contains any additional information to augment the Agent field
  // It will also contain the reason for ClusterAgent in "errored" phase
  // +optional
  optional string message = 2;

  // LastHeartBeat contains information about the timestamp at which the last
  // heartbeat from the ClusterAgent was recorded. It's in UTC.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastHeartBeat = 3;

  // Version determines the reported version of the ClusterAgent.
  optional string version = 4;
}

// ClusterAutoScalerOpts contain configuration for the Cluster AutoScaler (CAS)
// addon. This addon is only supported when using the azure or aws cloud
// provider.
message ClusterAutoScalerOpts {
  // Enabled signals that CAS should be installed on the cluster, if set.
  optional bool enabled = 1;

  // MinWorkers specifies the minimum number of the workers for the autoscaler
  // to maintain.
  optional int32 minWorkers = 2;

  // MaxWorkers specifies the maximum number of the workers for the autoscaler
  // to maintain.
  optional int32 maxWorkers = 3;
}

// ClusterList is a list of Cluster objects.
message ClusterList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta typeMeta = 3;

  // Standard list metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  // Items contains a list of Clusters.
  repeated Cluster items = 2;
}

// ClusterNetwork specifies the different networking parameters for a cluster.
message ClusterNetwork {
  // The network ranges from which service VIPs are allocated.
  // +optional
  optional string services = 1;

  // The network ranges from which Pod networks are allocated.
  // +optional
  optional string pods = 2;

  // Domain name for services.
  // Would be equal to ServiceFqdn in cluser_properties
  // +optional
  optional string serviceDomain = 3;
}

// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message ClusterProfile {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta typeMeta = 1;

  // Standard object's metadata.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 2;

  // Contents of the profile are stored separately but the location will be stored here
  optional ClusterProfileSpec spec = 3;

  // Current phase of the profile.
  // Valid values - draft, published, deleting, creating and errored
  // +optional
  optional ClusterProfileStatus status = 4;

  // User friendly description for the cluster profile
  // +optional
  optional string description = 5;
}

// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message ClusterProfileBinding {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta typeMeta = 1;

  // Standard object's metadata.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 2;

  // Spec will contain the cluster and the profile from which the drift is to be evaluated
  optional ClusterProfileBindingSpec spec = 3;

  // Current status of the binding a profile to a cluster.
  // Read only.
  // +optional
  optional ClusterProfileBindingStatus status = 4;
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message ClusterProfileBindingDetail {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta typeMeta = 1;

  // Standard object's metadata.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 4;

  // Data contains the actual contents of the cluster profile.
  optional string data = 2;

  // analysis contains the drift analysis of the resources on cluster against the profile for which this detail is uploaded.
  // same field to be used for "dryrun" operation
  optional string analysis = 3;
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message ClusterProfileBindingList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta typeMeta = 1;

  // Standard object's metadata.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 2;

  // Items contains the list of cluster profile bindings
  repeated ClusterProfileBinding items = 3;
}

message ClusterProfileBindingSpec {
  // ClusterRef contains the name of the cluster to which the clusterprofile should be applied
  // Points to cluster.metadata.name
  optional string clusterRef = 1;

  // ClusterRef contains the namespaced name of the profile which should be applied
  // format: namespace (projectID)/clusterprofile.metadata.name
  optional string profileRef = 2;

  // Dry run should be set to true to analyse the current resources on the cluster against the profile
  // If DryRun is set to true, the clusterProfileBinding resource will be removed automatically after
  // 10 minutes after completion i.e. Status.Phase == (ok/error)
  // +optional
  optional bool dryRun = 3;

  // Time in minutes after which the profile object will be removed from apiserver post deletion
  // default is 10 min
  // +optional
  optional int32 reapInterval = 4;
}

message ClusterProfileBindingStatus {
  // Current phase of the binding.
  // Valid values are - error, applying and ok
  optional string phase = 1;

  // Message field will contain any additional data to augment the phase field.
  optional string message = 2;

  // RetryCount is used to keep track of how many times the controller loop has
  // run since ClusterProfile resource is created till corresponding
  // ClusterProfileDetail is created.
  optional int32 retryCount = 4;
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message ClusterProfileDetail {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta typeMeta = 1;

  // Standard object's metadata.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 3;

  // Data contains the actual contents of the cluster profile.
  optional string data = 2;
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message ClusterProfileList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta typeMeta = 1;

  // Standard object's metadata.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 2;

  // Items contains the list of cluster profiles
  repeated ClusterProfile items = 3;
}

message ClusterProfileSpec {
  // NOTE: Either one of the following 2 fields, Location or ClonedFrom, must be specified
  // Cluster profile data i.e. the rules in the profile will be stored separately.
  // This field captures the same.
  // +optional
  optional string location = 1;

  // The identifier of the cluster or cluster profile from which this profile should be cloned.
  // Can either refer a cluster or a cluster profile
  // to refer to cluster profile the format must be "projectID (namespace)/clusterName"
  // Can be empty
  // +optional
  optional string cloneFrom = 2;

  // List of namespace scoped resources to be included in the profile.
  // Takes effect only when cloning from an existing cluster.
  // Each field must follow the format of "NamespaceName/Resource type name/Resource Name" e.g.
  // "kube-system/roles/extension-apiserver-authentication-reader"
  // "kube-system/rolebindings/system::extension-apiserver-authentication-reader"
  // +optional
  repeated string namespaceScopedResources = 3;

  // List of cluster scoped resources to be included in the profile.
  // Takes effect only when cloning from an existing cluster.
  // Each field must follow the format of "Resource type name/Resource Name" e.g.
  // "clusterroles/view"
  // "clusterrolebindings/system:basic-user"
  // +optional
  repeated string clusterScopedResources = 4;

  // Time in minutes after which the profile object will be removed from apiserver post deletion
  // default is 10 min
  // +optional
  optional int32 reapInterval = 5;
}

message ClusterProfileStatus {
  // Current phase of the profile.
  // Enum of - draft, published, deleted, create, error and uploading
  optional string phase = 1;

  // Conditions defines current service state of the ClusterProfile.
  // +optional
  repeated Condition conditions = 2;

  // Message contains any additional information to augment the Phase field
  // It will also contain the reason for ClusterProfile in "errored" phase
  // +optional
  optional string message = 3;

  // RetryCount is used to keep track of how many times the controller loop has
  // run since ClusterProfile resource is created till corresponding
  // ClusterProfileDetail is absent.
  optional int32 retryCount = 4;
}

// ClusterSpec contains the specification of the desired configuration of the Cluster.
message ClusterSpec {
  optional bool debug = 1;

  optional string cloudProviderID = 2;

  // ProjectID specifies the ID of the project that the Cluster.
  optional string projectID = 3;

  // KubeVersion is the target version of the control plane.
  // +optional
  optional string kubeVersion = 4;

  // Cluster network configuration.
  //
  // [qbert] clusters.containersCidr + clusters.servicesCidr
  // +optional
  optional ClusterNetwork clusterNetwork = 5;

  // KubeProxy contains settings for the kube-proxy service, which runs on
  // each node and manages forwarding of traffic addressed to the virtual IP
  // addresses (VIPs) of the cluster’s Kubernetes Service objects to the
  // appropriate backend pods.
  //
  // More info: https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/
  optional KubeProxyOpts kubeproxy = 6;

  // KubeletOpts contain Kubelet-specific configuration.
  //
  // See more: https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/
  optional KubeletOpts kubelet = 7;

  // KubeletOpts contain Kubelet-specific configuration.
  //
  // See more: https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/
  optional ContainerRuntime containerRuntime = 8;

  // LoadBalancer contains all specification related to ingress and the LoadBalancer service type.
  optional LoadBalancer loadBalancer = 9;

  // Based on the naming in kube-apiserver, where it calls etcd the 'storage-backend'.
  // See: https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/
  optional StorageBackend storageBackend = 10;

  // Auth contains all configuration related to cluster authentication and authorization.
  optional Auth auth = 11;

  // HA contians configuration related to highly-available API server support
  optional HA ha = 12;

  // Scheduler contains the settings for the kube-scheduler. The most
  // relevant parameters of the kube-scheduler are explicitly defined, all other
  // flags should be defined using the ExtraArgs field.
  //
  // More info: https://kubernetes.io/docs/reference/command-line-tools-reference/kube-scheduler
  optional KubeSchedulerOpts scheduler = 13;

  // ControllerManager contains the settings for the kube-controller-manager. The most
  // relevant parameters of the kube-controller-manager are explicitly defined, all other
  // flags should be defined using the ExtraArgs field.
  //
  // More info: https://kubernetes.io/docs/reference/command-line-tools-reference/kube-controller-manager
  optional KubeControllerManagerOpts controllerManager = 14;

  // Apiserver contains the settings for the kube-apiserver. The most
  // relevant parameters of the kube-apiserver are explicitly defined, all other
  // flags should be defined using the ExtraArgs field.
  //
  // More info: https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver
  optional KubeApiserverOpts apiserver = 15;

  // ControlPlaneEndpoint represents a predefined endpoint to be used to
  // communicate with the control plane.
  //
  // [qbert] clusters.masterIp/externalDNSName + clusters.k8sApiPort
  // +optional
  optional APIEndpoint controlPlaneEndpoint = 23;

  // CNI contains the CNI configuration, which includes general options,
  // as well as, CNI-specific settings. The current supported CNI plugins in
  // PMK are Calico, and Flannel, one of which should be non-empty based on
  // the NetworkPlugin field (calico or flannel, respectively).
  //
  // More info: https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/
  optional CNIOpts cni = 17;

  // Addons is an aggregation of all supported addons, which include Luigi,
  // Cluster AutoScaler (CAS), App Catalog, and KubeVirt.
  optional AddonsOpts addons = 18;

  // AllowWorkloadsOnMasters signals whether regular workloads are allowed to
  // be run on master nodes.
  optional bool allowWorkloadsOnMasters = 19;

  // VaultToken is the token used to generate the certificates with for the
  // cluster.
  optional string vaultToken = 20;

  // PF9 contains all miscellanuous configuration mostly related to specific
  // Platform9 services.
  optional PF9 pf9 = 21;

  // DisplayName provide human readable name to the cluster.
  // +optional
  optional string displayName = 22;

  // AWS contains all AWS-specific configuration for the cluster.
  optional AWSCluster aws = 24;

  // External defines that cluster is externally managed and PF9 is used as monitoring pane.
  // +optional
  optional bool external = 25;

  // EKS contains all EKS specific configuration for the cluster.
  // +optional
  optional EKSCluster eks = 26;

  // DockerPrivateRegistry is the location of the docker private registry (if any) that hosts the PF9 container images
  optional string dockerPrivateRegistry = 27;

  // QuayPrivateRegistry is the location of the quay private registry (if any) that hosts the PF9 container images
  optional string quayPrivateRegistry = 28;

  // GCRPrivateRegistry is the location of the gcr private registry (if any) that hosts the PF9 container images
  optional string gcrPrivateRegistry = 29;

  // K8SPrivateRegistry is the location of the k8s private registry (if any) that hosts the PF9 container images
  optional string k8sPrivateRegistry = 30;

  // UseHostname specifies the option for registering the bare OS node using
  // hostname (instead of the IP) in the PF9 managed k8s cluster. This option is only applicable to IPv4 hosts.
  // This option is ignored when deploying clusters on IPv6 enabled hosts.
  optional bool useHostname = 31;

  // AKS contains all AKS specific configuration for the cluster.
  // +optional
  optional AKSCluster aks = 32;

  // GKE contains all GKE specific configuration for the cluster.
  // +optional
  optional GKECluster gke = 33;
}

// ClusterStatus represents information about the status of a Cluster. Status may
// trail the actual state of a system, especially if the Hosts that make up the
// Cluster are not able to contact Sunpike.
message ClusterStatus {
  // Phase represents the current phase of cluster actuation.
  // E.g. Pending, Running, Terminating, Failed etc.
  //
  // [qbert] clusters.status
  // +optional
  optional string phase = 1;

  // Message is a human-readable string that summarizes why the Cluster in this phase.
  // +optional
  optional string message = 2;

  // Masters contains the number of master nodes currently part of this cluster.
  //
  // Although this can also be retrieved by listing the Hosts and finding those
  // belonging to this cluster, this field provides an alternative way for easier
  // API consumption.
  //
  // [qbert] clusters.numMasters
  // +optional
  optional int32 masters = 3;

  // Workers contains the number of worker nodes currently part of this cluster.
  //
  // Although this can also be retrieved by listing the Hosts and finding those
  // belonging to this cluster, this field provides an alternative way for easier
  // API consumption.
  //
  // [qbert] clusters.numWorkers
  // +optional
  optional int32 workers = 4;

  // ControlPlaneEndpoint represents the endpoint used to communicate with the control plane.
  // +optional
  optional string controlPlaneEndpoint = 5;

  // Type describes the controller-observed cloud type of this Cluster. This is
  // based on what subfields are set in the CloudProviderSpec.
  //
  // Although this can also be retrieved by looking up the CloudProvider
  // associated with this cluster, this field provides an alternative way for
  // easier API consumption.
  //
  // +optional
  optional string type = 6;

  // Conditions defines current service state of the Cluster.
  // +optional
  repeated Condition conditions = 7;

  // ObservedGeneration is the latest generation observed by the controller.
  // +optional
  optional int64 observedGeneration = 8;
}

// ClusterVersion is a representation of a supported version for Clusters.
//
// In qbert, this was known as a 'supported_version'.
message ClusterVersion {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta typeMeta = 1;

  // Standard object's metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 2;

  // Version is the full format of the ClusterVersion. Generally, this should
  // be the same as the ClusterVersion name. However, with the restricted
  // format of the name field, they can differ. In case there is a difference
  // this field should be viewed as authoritative.
  // Example: 1.2.3-pmk.1801
  optional string version = 3;

  // KubeVersion is the Kubernetes-portion of the Version.
  // Example: 1.2.3
  optional string kubeVersion = 4;

  // PMKVersion contains the PMK-portion of the Version.
  // Example: 1801
  optional string pmkVersion = 5;

  // Addons contains addon-specific information about the versioning.
  // +optional
  repeated ClusterVersionAddon addons = 6;

  // Changelog contains a URL to the location of the changelog for this ClusterVersion.
  // Example: http://example.com/changelog/1.2.3-pmk.1801
  // +optional
  optional string changelog = 7;

  // ReleasedAt specifies the time at which this version was released.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time releasedAt = 8;

  // Phase indicates the current state of this ClusterVersion.
  // Example: Active
  optional string phase = 9;
}

// ClusterVersionAddon contains addon-specific information about the versioning.
message ClusterVersionAddon {
  // Name is the name of the Addon.
  optional string name = 1;

  // Version contains the version of the Addon.
  optional string version = 2;
}

// ClusterVersionList is a list of ClusterVersion objects.
message ClusterVersionList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta typeMeta = 3;

  // Standard list metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  // Items contains a list of Providers.
  repeated ClusterVersion items = 2;
}

// Condition defines an observation of a Sunpike resource operational state.
//
// Note: the Condition type is adapted from Cluster API, mainly because properly
// importing Cluster API entails quite some dependency wrangling, and the fields lack
// protobuf tags.
message Condition {
  // Type of condition in CamelCase or in foo.example.com/CamelCase.
  // Many .condition.type values are consistent across resources like Available, but because arbitrary conditions
  // can be useful (see .node.status.conditions), the ability to deconflict is important.
  // +required
  optional string type = 1;

  // Status of the condition, one of True, False, Unknown.
  // +required
  optional string status = 2;

  // Severity provides an explicit classification of Reason code, so the users or machines can immediately
  // understand the current situation and act accordingly.
  // The Severity field MUST be set only when Status=False.
  // +optional
  optional string severity = 3;

  // Last time the condition transitioned from one status to another.
  // This should be when the underlying condition changed. If that is not known, then using the time when
  // the API field changed is acceptable.
  // +required
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;

  // The reason for the condition's last transition in CamelCase.
  // The specific API may choose whether or not this field is considered a guaranteed API.
  // This field may not be empty.
  // +optional
  optional string reason = 5;

  // A human readable message indicating details about the transition.
  // This field may be empty.
  // +optional
  optional string message = 6;
}

message ContainerRuntime {
  // DockerOpts are options for the Docker runtime on the Host.
  optional DockerOpts docker = 1;

  // Runtime specifies the container runtime to use
  optional string runtime = 2;
}

// DockerOpts are options for the Docker runtime on the Host.
message DockerOpts {
  // LiveRestore enables the Docker live restore capability, which ensures
  // that containers remain running if the daemon becomes (temporarily)
  // unavailable.
  //
  // More info: https://github.com/splunk/docker/blob/master/docs/admin/live-restore.md
  optional bool liveRestore = 1;

  // RootDir specifies the parent directory of the Docker daemon root
  // directory. By default, the RootDir is set to /var/lib. The reason that
  // you should provide the parent dir, is that in the phase scripts 'docker'
  // is affixed to this root path.
  optional string rootDir = 2;

  // DockerhubID contains the username of the Docker user to use when interacting
  // with the Dockerhub registry. Setting this will enable Docker to access
  // private repositories and mitigate the pull limits. If no ID is provided,
  // the Host will use unauthenticated requests to pull from the registry.
  optional string dockerhubID = 3;

  // DockerhubPassword contains the password of the Docker user to use when
  // interacting with the Dockerhub registry. Setting this will enable Docker to
  // access private repositories and mitigate the pull limits. If no password is
  // provided, the Host will use unauthenticated requests to pull from the registry.
  optional string dockerhubPassword = 4;

  // RegistryMirrors specifies the Dockerhub mirrors that should be tried for
  // pulling images. The mirrors should be formatted as comma-seperated list
  // of URLs.
  //
  // More info: https://docs.docker.com/registry/recipes/mirror/
  // or https://cloud.google.com/container-registry/docs/pulling-cached-images
  optional string registryMirrors = 5;

  // Docker's Centos Package Repo URL. This will be added to the various mirror Platform9 uses.
  // defaults to empty which means default OS supported repo would be used
  // this is useful when customers want to control what docker version is installed
  optional string dockerCentosPackageRepoUrl = 6;

  // Docker's Ubuntu Package Repo URL. This will be added to the various mirror Platform9 uses.
  // defaults to empty which means default OS supported repo would be used
  // this is useful when customers want to control what docker version is installed
  optional string dockerUbuntuPackageRepoUrl = 7;
}

// EC2Instance represents information about EC2 instances in AWS.
// More info:https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Instances.html
message EC2Instance {
  // InstanceID represents identifier of instance.
  // +optional
  optional string instanceId = 1;

  // The AZ in which the instance was created.
  // +optional
  optional string availabilityZone = 2;

  // The type of the instance.
  // +optional
  optional string instanceType = 3;

  // The ntwork properties associated with the instance.
  // +optional
  optional EC2InstanceNetwork network = 4;
}

// EC2InstanceNetwork represents the network information for
// the EC2 instance.
message EC2InstanceNetwork {
  // +optional
  optional string privateDnsName = 1;

  // +optional
  optional string publicDnsName = 2;

  // +optional
  optional string privateIpAddress = 3;

  // +optional
  optional string publicIpAddress = 4;

  // +optional
  optional string subnet = 5;

  // +optional
  optional string vpcId = 6;
}

// EKSCluster defines spec for the k8s cluster created
// and managed as part of AWS.
// More https://docs.aws.amazon.com/eks/latest/APIReference/eks-api.pdf#Welcome
message EKSCluster {
  // Region explains the region in which the EKSCluster is present.
  optional string region = 1;

  // KubernetesVersion informs us about the kubernetes version on the cluster.
  optional string kubernetesVersion = 2;

  // EKSVersion is the internal eks version for a given k8s version.
  optional string eksVersion = 3;

  // CreatedAt informs the time at which the cluster got created.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time createdAt = 4;

  // Status tells us about the cluster status.
  // +optional
  optional string status = 5;

  // CA tells us the certificate authority data for the cluster
  // +optional
  optional string ca = 6;

  // The arn of the amazon IAM role that provides permissions to make API calls to AWS Resources.
  // +optional
  optional string iamRole = 7;

  // The K8s Networking config for cluster.
  // +optional
  optional EKSNetwork network = 8;

  // Object representing logging configuration for resources in cluster.
  // +optional
  optional EKSLogging logging = 9;

  // Metadata to be applied to cluster for categorization and organisation.
  // +optional
  map<string, string> tags = 10;

  // Cluster managed node groups.
  // +optional
  repeated EKSNodeGroup nodegroups = 11;
}

// EKSClusterLogging lays out the structure encapsulating
// logging in eks clusters.
message EKSClusterLogging {
  // +optional
  repeated string types = 1;

  // +optional
  optional bool enabled = 2;
}

// EKSLogging provides information about the logging
// enabled in eks cluster.
message EKSLogging {
  // Logging information for resources in the cluster.
  // +optional
  repeated EKSClusterLogging clusterLogging = 1;
}

// EKSNetwork provides networking aspect of the
// EKSCluster.
message EKSNetwork {
  // +optional
  repeated string containerCidr = 1;

  // +optional
  optional string servicesCidr = 2;

  // +optional
  optional AWSVPC vpc = 3;
}

// EKSNodeGroup provides information about the instances used
// in EKS Cluster.
message EKSNodeGroup {
  // Name describes the name associated with the nodegroup.
  optional string name = 1;

  // ARN associated with the nodegroup.
  optional string arn = 2;

  // k8s version of the nodegroup.
  optional string kubernetesVersion = 3;

  // Time at which the node group was created.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time createdAt = 4;

  // Last time at which the node group was updated.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time updatedAt = 5;

  // Status of the nodegroup.
  // +optional
  optional string status = 6;

  // The capacity type of the nodegroup.
  // +optional
  optional string capacityType = 7;

  // The types of instances in the nodegroup.
  // +optional
  repeated string instanceTypes = 8;

  // The subnets for the autoscaling group that was associated with the nodegroup.
  // +optional
  repeated string subnets = 9;

  // The type of the ami that was supplied in the configuration.
  // +optional
  optional string ami = 10;

  // User specified tags on the nodegroups.
  // +optional
  map<string, string> tags = 11;

  // User specified labels on the nodegroups.
  // +optional
  map<string, string> labels = 12;

  // Identifier of the sshkey that provides access to the ec2 instances in nodegroups.
  // +optional
  optional string sshKey = 13;

  // Scaling configuration associated with the nodegroup.
  // +optional
  optional AWSScalingConfig scalingConfig = 14;

  // The root device disk size for instances in nodegroups.
  // +optional
  optional int32 diskSizeInGiB = 15;

  // The ARN of the IAM role associated with nodegroups.
  // +optional
  optional string iamRole = 16;

  // The instances as part of the nodegroup.
  // +optional
  repeated EC2Instance instances = 17;
}

// EtcdOpts contain configuration for the etcd cluster as a storage backend for
// the Cluster.
//
// More info: https://etcd.io/docs/latest/op-guide/configuration/
message EtcdOpts {
  // DataDir specifies the path on the Host (!) where the etcd data should
  // be stored.
  optional string dataDir = 1;

  // DiscoveryURL is used to bootstrap the cluster.
  // Note(erwin): does not seem to be used.
  optional string discoveryURL = 2;

  // ElectionTimeout is the time (in milliseconds) for an election to timeout.
  // It is equivalent to the –-election-timeout flag in etcd.
  //
  // More info: https://etcd.io/docs/latest/tuning/#time-parameters
  optional int32 electionTimeout = 3;

  // Env is a catch-all field to specify any environment variables that will
  // be propagated to etcd. The environment variables in this field are
  // line-separated. For example:
  //      ETCD_NAME=08e5cfc1-0e35-4ddb-8fd5-0ae68383c831
  //      ETCD_STRICT_RECONFIG_CHECK=true
  //      ETCD_INITIAL_CLUSTER_TOKEN=9a3fb982-4a6d-4c93-896a-fd8e77577c63
  //      ETCD_INITIAL_CLUSTER_STATE=new
  //
  // For the possible environment variables see: https://etcd.io/docs/latest/op-guide/configuration/
  optional string env = 4;

  // HeartbeatIntervalMs specifies time (in milliseconds) of a heartbeat interval.
  optional int32 heartbeatIntervalMs = 5;

  // Version specifies the version of etcd to run.
  optional string version = 6;
}

// FlannelOpts are options for the Flannel CNI plugin.
//
// See more: https://github.com/coreos/flannel/blob/master/Documentation/configuration.md
message FlannelOpts {
  // InterfaceLabel to use (IP or name) for inter-host communication. Defaults
  // to the interface for the default route on the machine.
  optional string interfaceLabel = 1;

  // PublicInterfaceLabel specifies the IP accessible by other nodes for
  // inter-host communication. Defaults to the IP of the interface being used
  // for communication.
  optional string publicInterfaceLabel = 2;
}

// GKECluster is Google Kubernetes Engine cluster.
// https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1beta1/projects.zones.clusters
message GKECluster {
  // The list of Google Compute Engine zones in which the cluster's nodes should be located.
  repeated string locations = 1;

  // Unique id for the cluster.
  optional string id = 2;

  // ClusterCACertificate is a base64-encoded public certificate that is the root of trust for the cluster.
  optional string clusterCaCertificate = 3;

  // The initial Kubernetes version for this cluster.
  optional string initialClusterVersion = 4;

  // The Channel specifies which release channel the cluster is subscribed to.
  optional string releaseChannel = 5;

  // The DatabaseEncryption denotes the state of etcd encryption.
  optional string databaseEncryption = 6;

  // Cluster network details
  // +optional
  optional GKEClusterNetwork network = 7;

  // Array of nodepools associated with the cluster
  // +optional
  repeated GKENodePool nodePools = 8;

  // PrivateCluster indicates whether a cluster access is limited to a private network only
  // +optional
  optional bool privateCluster = 9;
}

// GKEClusterNetwork
message GKEClusterNetwork {
  // UseIpAliases indicates whether alias IPs is used for pod IPs in the cluster.
  optional bool useIpAliases = 1;

  // The relative name of the Google Compute Engine network to which the cluster is connected
  optional string network = 2;

  // The relative name of the Google Compute Engine subnetwork to which the cluster is connected.
  optional string subnetwork = 3;

  // The IP address range of the container pods in this cluster, in CIDR notation
  optional string podIpv4CIDR = 4;

  // The IP address range of the Kubernetes services in this cluster, in CIDR notation
  optional string servicesIpv4CIDR = 5;

  // NetworkPolicyConfig indicates whether NetworkPolicy is enabled for this cluster.
  optional bool networkPolicyConfig = 6;
}

// GKEInstance is an instance in an instance group that is a part of a GKE cluster node pool
// https://cloud.google.com/workflows/docs/reference/googleapis/compute/v1/Overview?hl=en#ManagedInstance
message GKEInstance {
  // Name of the instance
  optional string name = 1;

  // Status of the instance
  optional string status = 2;

  // ID of the instance is a GUID
  optional string id = 3;

  // Location of the instance
  optional string location = 4;

  // InstanceTemplate used for creating the instance
  optional string instanceTemplate = 5;

  // InstanceGroupName is the instance group that contains this instance
  optional string instanceGroupName = 6;
}

// GKENodePool is a group of nodes within a cluster
// https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1beta1/projects.zones.clusters.nodePools
message GKENodePool {
  // The name of the node pool.
  optional string name = 1;

  // Size of the disk attached to each node, specified in GB.
  optional int32 diskSizeGb = 2;

  // The name of a Google Compute Engine machine type
  optional string machineType = 3;

  // The image type to use for this node.
  optional string imageType = 4;

  // Type of the disk attached to each node (e.g. 'pd-standard', 'pd-ssd' or 'pd-balanced')
  optional string diskType = 5;

  // The initial node count for the pool
  optional int32 nodeCount = 6;

  // The constraint on the maximum number of pods that can be run simultaneously on a node in the node pool.
  optional string maxPodsPerNode = 7;

  // The status of the nodes in this pool instance.
  optional string status = 8;

  // The version of the Kubernetes of this node.
  optional string k8sVersion = 9;

  // The list of Google Compute Engine zones in which the NodePool's nodes should be located.
  repeated string locations = 10;

  // Array of GKEInstances that make up the GKE cluster nodes
  // +optional
  repeated GKEInstance instances = 11;
}

// GoogleCloudProviderCredentials contains all Google Cloud-specific configuration for a CloudProvider.
message GoogleCloudProviderCredentials {
  // Type denotes the type of account
  optional string type = 1;

  // ProjectID is your Google Cloud project ID
  optional string projectID = 2;

  // PrivateKeyID is an identifier for your private key
  optional string privateKeyID = 3;

  // PrivateKey is the private key data associated with your service account JSON key
  optional string privateKey = 4;

  // ClientEmail is the email associated with the service account
  optional string clientEmail = 5;

  // ClientID is an identifier for this client
  optional string clientID = 6;

  // AuthURI is the auth endpoint to be used with this key
  optional string authURI = 7;

  // TokenURI is the token endpoint to be used with this key
  optional string tokenURI = 8;

  // AuthProviderx509CertURL is the endpoint for provider certs
  optional string authProviderx509CertURL = 9;

  // Clientx509CertURL is the endpoint for client certs
  optional string clientx509CertURL = 10;
}

message GoogleCloudProviderSpec {
  // SecretName contains a reference to the secret in the same namespace in
  // which the GCP credentials are stored.
  optional string secretName = 1;
}

message HA {
  // For HA setup
  optional KeepalivedOpts keepalived = 1;
}

// KeepalivedOpts contains the settings to configure keepalived, which is used
// to handle failovers of a virtual IP in a multi master deployment on bare OS
// cluster.
//
// More info: https://www.keepalived.org/manpage.html
message KeepalivedOpts {
  // Enabled signals whether keepalived should be configured on the cluster.
  optional bool enabled = 1;

  optional string masterVIPInterface = 2;

  // MasterVIPPriority is for electing MASTER, highest priority wins.
  // Note(erwin): seems to be unused.
  optional string masterVIPPriority = 3;

  // MasterVIPRouterID is an arbitrary unique number from 1 to 255 used to
  // differentiate multiple instances of vrrpd running on the same NIC
  // (and hence same socket).
  optional string masterVIPRouterID = 4;
}

// KeystoneOpts is the container for all settings related to authentication with
// the OpenStack Keystone identity service.
// Note(erwin): this does not seem to be used by pf9-kube, so this could be left out.
//
// More info: https://docs.openstack.org/keystone/latest/
message KeystoneOpts {
  // Enabled signals whether Keystone should be used for authentication.
  optional bool enabled = 1;

  // Domain contains the DNS name of the Keystone service.
  optional string domain = 2;

  // AuthURL should contain the base URL to the Keystone service.
  optional string authURL = 3;

  optional string password = 4;

  optional string username = 5;

  optional string projectDomainName = 6;

  optional string projectName = 7;

  optional string region = 8;

  optional string userDomainName = 9;
}

// KubeApiserverOpts contains the settings for the kube-apiserver. The most
// relevant parameters of the kube-apiserver are explicitly defined, all other
// flags should be defined using the ExtraArgs field.
//
// More info: https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver
message KubeApiserverOpts {
  // StorageBackend defines the storage backend for persistence.
  // Options: 'etcd3'
  // This is equivalent to the --storage-backend flag for kube-apiserver.
  optional string storageBackend = 1;

  // Privileged allows this cluster to run privileged containers. This is
  // required for Calico CNI and CSI.
  // This is equivalent to the --allow-privileged flag for kube-apiserver.
  //
  // More info: https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities
  optional bool privileged = 2;

  // Port specifies the HTTPS port on which the kube-apiserver should be
  // served.
  // This is equivalent to the --secure-port flag for kube-apiserver.
  optional int32 port = 3;

  // Authz indicates if authorization should be enabled on the kube-apiserver.
  // This option has been deprecated since authorization has been enabled by
  // default since Kubernetes 1.10. This field is no longer used by scripts.
  optional bool authz = 4;

  // RuntimeConfig is comma-separated list of key=value pairs.
  //
  // Equivalent to the --runtime-config of kube-apiserver.
  optional string runtimeConfig = 5;

  // ExtraArgs is a catch-all for all flags of kube-apiserver that are not
  // present as an explicit field. These flags should be seperated with a ",".
  // For example: --skip-log-headers,--tls-min-version=VersionTLS11
  optional string extraArgs = 6;
}

// KubeControllerManagerOpts contains the settings for the kube-controller-manager. The most
// relevant parameters of the kube-controller-manager are explicitly defined, all other
// flags should be defined using the ExtraArgs field.
//
// More info: https://kubernetes.io/docs/reference/command-line-tools-reference/kube-controller-manager
message KubeControllerManagerOpts {
  // ExtraArgs is a catch-all for all flags of kube-controller-manager that are not
  // present as an explicit field. These flags should be separated with a ",".
  // For example: --skip-log-headers,--tls-min-version=VersionTLS11
  optional string extraArgs = 1;
}

// KubeProxyOpts contain settings for the kube-proxy service, which runs on each
// node and manages forwarding of traffic addressed to the virtual IP addresses
// (VIPs) of the cluster’s Kubernetes Service objects to the appropriate
// backend pods.
//
// More info: https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/
message KubeProxyOpts {
  // Which proxy mode to use: 'userspace' (older) or 'iptables' (faster) or
  // 'ipvs' or 'kernelspace' (windows). If blank, use the best-available
  // proxy (currently iptables). If the iptables proxy is selected,
  // regardless of how, but the system's kernel or iptables versions are
  // insufficient, this always falls back to the userspace proxy.
  optional string mode = 1;
}

// KubeSchedulerOpts contains the settings for the kube-scheduler. The most
// relevant parameters of the kube-scheduler are explicitly defined, all other
// flags should be defined using the ExtraArgs field.
//
// More info: https://kubernetes.io/docs/reference/command-line-tools-reference/kube-scheduler
message KubeSchedulerOpts {
  // ExtraArgs is a catch-all for all flags of kube-scheduler that are not
  // present as an explicit field. These flags should be separated with a ",".
  // For example: --skip-log-headers,--tls-min-version=VersionTLS11
  optional string extraArgs = 1;
}

// KubeVirtOpts contain configuration for the KubeVirt addon.
message KubeVirtOpts {
  // Enabled signals that KubeVirt should be installed on the cluster, if set.
  optional bool enabled = 1;
}

// KubeletOpts contain Kubelet-specific configuration.
//
// See more: https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/
message KubeletOpts {
  // CloudCfg contains the configuration data that will be used in the
  // --cloud-config flag of kubelet. Empty string for no configuration data.
  //
  // (DEPRECATED: will be removed in 1.23, in favor of removing cloud
  // providers code from Kubelet.)
  optional string cloudCfg = 1;

  // ProviderID contains the provider ID that is specified by CAPI machine and
  // will be populated in the kubelet running on the host.
  optional string providerID = 2;

  // ExtraArgs contains arguments that will be passed as-is to kubelet process
  optional string extraArgs = 3;

  // NodeLabels contains labels for the host
  map<string, string> nodeLabels = 4;

  // NodeTaints contains taints for the host
  map<string, string> nodeTaints = 5;
}

message LoadBalancer {
  // MetalLB specifies the options for the MetalLB addon which provides
  // support for load-balancer services.
  //
  // More info: https://metallb.universe.tf
  optional MetalLBOpts metallb = 1;
}

// LocalCloudProviderSpec contains all configuration specific to a on-premise CloudProvider.
message LocalCloudProviderSpec {
}

// LuigiOpts contain configuration for the Luigi addon.
message LuigiOpts {
  // Enabled signals that Luigi should be installed on the cluster, if set.
  optional bool enabled = 1;
}

// MetalLBOpts are the options for the MetalLB addon which provides support for
// load-balancer services.
//
// More info: https://metallb.universe.tf
message MetalLBOpts {
  // CIDR contains the address range to give MetalLB control over. These will
  // be assigned to services with the type LoadBalancer.
  //
  // Examples: 192.168.1.240-192.168.1.250 or 10.21.0.0/22
  optional string CIDR = 1;

  // Enabled signals that the addon should be installed on the cluster, if set.
  optional bool enabled = 2;
}

// Override defines params to override in the addon
message Override {
  // Params list of override params
  repeated Params params = 1;
}

// PF9 contains miscellaneous configuration, mostly related to PF9 services.
message PF9 {
  // Masterless, if set, instructs the cluster to run a proxy to a remote
  // apiserver, rather than running the apiserver in-cluster.
  optional bool masterless = 1;

  // BouncerSlowReqWebhook is a field to enable code instrumentation to be
  // able to detect keystone slowness in some environments. It is unclear
  // whether this is still used.
  //
  // More info: https://platform9.atlassian.net/browse/INF-764
  optional string bouncerSlowReqWebhook = 2;

  // isAirgapped specifies whether cluster is running in airgapped or SaaS env
  optional bool isAirgapped = 3;
}

// Params defines params to override in the addon
message Params {
  // Name of the parameter to override, should be present in the yaml
  optional string name = 1;

  // Value of the overridden parameter
  optional string value = 2;
}

// ProfileAgentOpts contains configuration related to platform9 profile engine agent
message ProfileAgentOpts {
  // Enabled signals that profile agent should be installed on the cluster, if set.
  optional bool enabled = 1;
}

// Region resembles a cloud region.
message Region {
  // Name is unique identifier of the region.
  //
  // Example: us-west-2
  optional string name = 1;

  // DisplayName is a human-readable version of the Name.
  //
  // Generally the same as Name but it can differ based on the CloudProvider.
  // +optional
  optional string displayName = 2;
}

message StorageBackend {
  // Etcd contain configuration for the etcd cluster as a storage backend for
  // the Cluster. This is separated from the apiserver settings, because we
  // plan to separate out etcd from the master nodes.
  //
  // More info: https://etcd.io/docs/latest/
  optional EtcdOpts etcd = 1;
}

// The pod this Toleration is attached to tolerates any taint that matches
// the triple <key,value,effect> using the matching operator <operator>.
message Toleration {
  // Key is the taint key that the toleration applies to. Empty means match all taint keys.
  // If the key is empty, operator must be Exists; this combination means to match all values and all keys.
  // +optional
  optional string key = 1;

  // Operator represents a key's relationship to the value.
  // Valid operators are Exists and Equal. Defaults to Equal.
  // Exists is equivalent to wildcard for value, so that a pod can
  // tolerate all taints of a particular category.
  // +optional
  optional string operator = 2;

  // Value is the taint value the toleration matches to.
  // If the operator is Exists, the value should be empty, otherwise just a regular string.
  // +optional
  optional string value = 3;

  // Effect indicates the taint effect to match. Empty means match all taint effects.
  // When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
  // +optional
  optional string effect = 4;

  // TolerationSeconds represents the period of time the toleration (which must be
  // of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
  // it is not set, which means tolerate the taint forever (do not evict). Zero and
  // negative values will be treated as 0 (evict immediately) by the system.
  // +optional
  optional int64 tolerationSeconds = 5;
}

