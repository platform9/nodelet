/*
Copyright (C) 2015-2020 Platform9 Systems, Inc.
*/


// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = "proto2";

package github.com.platform9.pf9_qbert.sunpike.apiserver.pkg.apis.sunpike.v1alpha1;

import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/schema/generated.proto";

// Package-wide variables from generator "generated".
option go_package = "v1alpha1";

// AddonsOpts is an aggregation of all supported addons.
message AddonsOpts {
  // AppCatalog specifies if and how the App Catalog addon should be
  // installed in the cluster.
  optional AppCatalogOpts appCatalog = 1;

  // CAS specifies if and how the Cluster AutoScaler addon should be
  // deployed in the cluster.
  optional ClusterAutoScalerOpts CAS = 2;

  // Luigi contains the settings for the Luigi addons, if enabled.
  optional LuigiOpts luigi = 3;

  // Kubevirt specifies if and how the KubeVirt addon should be
  // installed in the cluster.
  optional KubeVirtOpts kubevirt = 4;

  // CPUManager defines the options used to manage the CPU and topology
  // manager feature.
  optional CPUManagerOpts cpuManager = 5;

  // ProfileAgent defines the options used to manage and configure the platform9 profile engine agent on the clsuter
  optional ProfileAgentOpts profileAgent = 6;
}

// AppCatalogOpts contain configuration for the App Catalog addon.
message AppCatalogOpts {
  // Enabled signals that AppCatalog should be installed on the cluster, if set.
  optional bool enabled = 1;
}

// CNIOpts contains the CNI configuration, which includes general options,
// as well as, CNI-specific settings. Current supported CNI plugins are Calico,
// and Flannel, one of which should be non-empty based on the NetworkPlugin
// field (calico or flannel, respectively).
message CNIOpts {
  // Bridge specifies the CNI bridge to use.
  // Note(erwin): this seems to be used only for flannel.
  optional string bridge = 1;

  // MTUSize configures the MTU to use for workload interfaces and the tunnels.
  // Note(erwin): this seems to be used only for calico.
  optional int32 MTUSize = 2;

  // IPv6 indicates whether this cluster should support IPv6.
  // Note(erwin): this seems to be used only for calico.
  optional bool IPv6 = 3;

  // NetworkPlugin specifies the CNI plugin to use for this cluster. The
  // options are: calico or flannel. Based on this setting either the Calico
  // field should be filled, or the Flannel field should be filled.
  optional string networkPlugin = 4;

  // Calico contains options specific to the Calico CNI plugin.
  optional CalicoOpts calico = 5;

  // Flannel contains options specific to the Flannel CNI plugin.
  //
  // More info: https://github.com/coreos/flannel/blob/master/Documentation/configuration.md
  optional FlannelOpts flannel = 6;
}

// CPUManagerOpts defines the options used to manage the CPU and topology manager feature
message CPUManagerOpts {
  optional string cpuManagerPolicy = 1;

  optional string topologyManagerPolicy = 2;

  optional string reservedCPUs = 3;
}

// CalicoOpts are options for the Calico CNI plugin.
//
// More info: https://docs.projectcalico.org/reference/node/configuration
message CalicoOpts {
  // IPIPMode is the IPIP Mode to use for the IPv4 POOL created at start up.
  // Options: Always, CrossSubnet, Never (“Off” is also accepted as a synonym for “Never”)
  //
  // Corresponds to the CALICO_IPV4POOL_IPIP environment variable in Calico.
  optional string IPIPMode = 1;

  // IPv4BlkSize is the block size to use for the IPv4 POOL created at
  // startup. Block size for IPv4 should be in the range 20-32 (inclusive).
  //
  // Corresponds to the CALICO_IPV4POOL_BLOCK_SIZE environment variable in Calico.
  optional int32 IPv4BlkSize = 2;

  // NatOutgoing controls whether the NAT Outgoing for the IPv4 Pool should
  // be created at start up.
  //
  // Corresponds to the CALICO_IPV4POOL_NAT_OUTGOING environment variable in Calico.
  optional bool NatOutgoing = 3;

  // IPv4Mode is the IPv4 address to assign this host or detection behavior
  // at startup. For the details of the behavior possible with this field,
  // see: https://docs.projectcalico.org/reference/node/configuration#ip-setting
  //
  // Corresponds to the IP environment variable in Calico.
  optional string IPv4Mode = 4;

  // IPv4DetectionMethod specifies the method to use to autodetect the IPv4
  // address for this host. This is only used when the IPv4 address is being
  // autodetected. For details of the valid methods, see:
  // https://docs.projectcalico.org/reference/node/configuration#ip-autodetection-methods
  //
  // Corresponds to the IP_AUTODETECTION_METHOD environment variable in Calico.
  optional string IPv4DetectionMethod = 5;

  // IPv6Mode is the IPv6 address to assign this host or detection behavior
  // at startup. For the details of the behavior possible with this field,
  // see: https://docs.projectcalico.org/reference/node/configuration#ip-setting
  //
  // Corresponds to the IP6 environment variable in Calico.
  optional string IPv6Mode = 6;

  // IPv6BlkSize is the block size to use for the IPv6 POOL created at
  // startup. Block size for IPv6 should be in the range 116-128 (inclusive).
  //
  // Corresponds to the CALICO_IPV6POOL_BLOCK_SIZE environment variable in Calico.
  optional int32 IPv6BlkSize = 7;

  // IPv6PoolCIDR specifies the IPv6 Pool to create if none exists at start-up.
  //
  // Corresponds to the CALICO_IPV6POOL_CIDR environment variable in Calico.
  optional string IPv6PoolCIDR = 8;

  // IPv6PoolNAT controls whether NAT Outgoing for the IPv6 Pool should be
  // created at start up.
  //
  // Corresponds to the CALICO_IPV6POOL_NAT_OUTGOING environment variable in Calico.
  optional bool IPv6PoolNAT = 9;

  // IPv6DetectionMethod specifies the method to use to autodetect the IPv4
  // address for this host. This is only used when the IPv6 address is being
  // autodetected. For details of the valid methods, see:
  // https://docs.projectcalico.org/reference/node/configuration#ip-autodetection-methods
  //
  // Corresponds to the IP6_AUTODETECTION_METHOD environment variable in Calico.
  optional string IPv6DetectionMethod = 10;

  // RouterID sets the router id to use for BGP if no IPv4 address is set on
  // the node. For an IPv6-only system, this may be set to hash. It then uses
  // the hash of the nodename to create a 4 byte router id.
  //
  // Corresponds to the CALICO_ROUTER_ID environment variable in Calico.
  optional string routerID = 11;

  // FelixIPv6Support enables Calico networking and security for IPv6 traffic
  // as well as for IPv4.
  //
  // More info: https://docs.projectcalico.org/reference/felix/configuration
  optional bool felixIPv6Support = 12;
}

// ClusterAutoScalerOpts contain configuration for the Cluster AutoScaler (CAS)
// addon. This addon is only supported when using the azure or aws cloud
// provider.
message ClusterAutoScalerOpts {
  // Enabled signals that CAS should be installed on the cluster, if set.
  optional bool enabled = 1;

  // MinWorkers specifies the minimum number of the workers for the autoscaler
  // to maintain.
  optional int32 minWorkers = 2;

  // MaxWorkers specifies the maximum number of the workers for the autoscaler
  // to maintain.
  optional int32 maxWorkers = 3;
}

// DockerOpts are options for the Docker runtime on the Host.
message DockerOpts {
  // LiveRestore enables the Docker live restore capability, which ensures
  // that containers remain running if the daemon becomes (temporarily)
  // unavailable.
  //
  // More info: https://github.com/splunk/docker/blob/master/docs/admin/live-restore.md
  optional bool liveRestore = 1;

  // RootDir specifies the parent directory of the Docker daemon root
  // directory. By default, the RootDir is set to /var/lib. The reason that
  // you should provide the parent dir, is that in the phase scripts 'docker'
  // is affixed to this root path.
  optional string rootDir = 2;

  // DockerhubID contains the username of the Docker user to use when interacting
  // with the Dockerhub registry. Setting this will enable Docker to access
  // private repositories and mitigate the pull limits. If no ID is provided,
  // the Host will use unauthenticated requests to pull from the registry.
  optional string dockerhubID = 3;

  // DockerhubPassword contains the password of the Docker user to use when
  // interacting with the Dockerhub registry. Setting this will enable Docker to
  // access private repositories and mitigate the pull limits. If no password is
  // provided, the Host will use unauthenticated requests to pull from the registry.
  optional string dockerhubPassword = 4;

  // RegistryMirrors specifies the Dockerhub mirrors that should be tried for
  // pulling images. The mirrors should be formatted as comma-seperated list
  // of URLs.
  //
  // More info: https://docs.docker.com/registry/recipes/mirror/
  // or https://cloud.google.com/container-registry/docs/pulling-cached-images
  optional string registryMirrors = 5;

  // Docker's Centos Package Repo URL. This will be added to the various mirror Platform9 uses.
  // defaults to empty which means default OS supported repo would be used
  // this is useful when customers want to control what docker version is installed
  optional string dockerCentosPackageRepoUrl = 6;

  // Docker's Ubuntu Package Repo URL. This will be added to the various mirror Platform9 uses.
  // defaults to empty which means default OS supported repo would be used
  // this is useful when customers want to control what docker version is installed
  optional string dockerUbuntuPackageRepoUrl = 7;
}

// EtcdOpts contain configuration for the etcd cluster as a storage backend for
// the Cluster.
//
// More info: https://etcd.io/docs/latest/op-guide/configuration/
message EtcdOpts {
  // DataDir specifies the path on the Host (!) where the etcd data should
  // be stored.
  optional string dataDir = 1;

  // DiscoveryURL is used to bootstrap the cluster.
  // Note(erwin): does not seem to be used.
  optional string discoveryURL = 2;

  // ElectionTimeout is the time (in milliseconds) for an election to timeout.
  // It is equivalent to the –-election-timeout flag in etcd.
  //
  // More info: https://etcd.io/docs/latest/tuning/#time-parameters
  optional int32 electionTimeout = 3;

  // Env is a catch-all field to specify any environment variables that will
  // be propagated to etcd. The environment variables in this field are
  // line-separated. For example:
  //      ETCD_NAME=08e5cfc1-0e35-4ddb-8fd5-0ae68383c831
  //      ETCD_STRICT_RECONFIG_CHECK=true
  //      ETCD_INITIAL_CLUSTER_TOKEN=9a3fb982-4a6d-4c93-896a-fd8e77577c63
  //      ETCD_INITIAL_CLUSTER_STATE=new
  //
  // For the possible environment variables see: https://etcd.io/docs/latest/op-guide/configuration/
  optional string env = 4;

  // HeartbeatIntervalMs specifies time (in milliseconds) of a heartbeat interval.
  optional int32 heartbeatIntervalMs = 5;

  // Version specifies the version of etcd to run.
  optional string version = 6;
}

// FlannelOpts are options for the Flannel CNI plugin.
//
// See more: https://github.com/coreos/flannel/blob/master/Documentation/configuration.md
message FlannelOpts {
  // InterfaceLabel to use (IP or name) for inter-host communication. Defaults
  // to the interface for the default route on the machine.
  optional string interfaceLabel = 1;

  // PublicInterfaceLabel specifies the IP accessible by other nodes for
  // inter-host communication. Defaults to the IP of the interface being used
  // for communication.
  optional string publicInterfaceLabel = 2;
}

// Host is a representation of the configuration and status of a single machine.
message Host {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta typeMeta = 4;

  // Standard object's metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  // Specification of the desired behavior of the Host.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional HostSpec spec = 2;

  // Most recently observed status of the Host.
  // This data may not be up to date.
  // Populated by the system.
  // Read-only.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional HostStatus status = 3;
}

// HostList is a list of Host objects.
message HostList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta typeMeta = 3;

  // Standard list metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  // Items contains a list of Hosts.
  repeated Host items = 2;
}

// HostPhase contains the status of a single phase script.
message HostPhase {
  // Name provides a human-readable name for this phase. These names can
  // contain special characters and spaces.
  //
  // Example: "Configure and start auth web hook / pf9-bouncer"
  optional string name = 1;

  // Order is a unique number that is used to determine the order of the
  // phases. The phases are ordered ascendingly based on this field.
  optional int32 order = 2;

  // StartedAt indicates when this phase started running.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time startedAt = 3;

  // Operation describes the type of operation that the phase is currently
  // performing. Options: start|stop|status.
  optional string operation = 4;

  // Status describes the current state of the phase.
  //
  // Options:
  // - not-started: state when no operation has been performed.
  // - running:     state when start operation was successful.
  // - stopped:     state when stop operation was successful.
  // - failed:      state when start operation has failed.
  // - executing:   state when an operation is being performed on a phase.
  optional string status = 5;

  // Message is a human readable description indicating details about why the
  // phase is in this status.
  //
  // When the status is an error, the Message contains the error message.
  optional string message = 6;
}

// HostSpec contains the specification of the desired behavior of the Host.
//
// Dev note: This type MUST be kept in sync with server/sunpike.js in qbert.
// Make sure update both data structures when adding/modifying new fields.
message HostSpec {
  // The goal of ExtraCfg is to hold any additional args that have not been
  // formalized yet. Based on discussions with Raghvendra, Arun and Abhimanyu
  // regarding multi-version support it might be beneficial to have a
  // free-form dict object and enforce the validation in the API layer based
  // on a schema that is NOT hardcoded in sunpike.
  map<string, string> extraCfg = 1;

  // PF9Cfg contains miscellaneous configuration related to PF9 services.
  optional PF9Opts pf9 = 2;

  // ClusterCfg contains the cluster-wide configuration. These settings
  // include the control plane (apiserver, scheduler, and controller-manager),
  // networking (CNI, KubeProxy), and the ingress load-balancing (MetalLB).
  optional KubeClusterOpts clusterCfg = 3;

  // Etcd contain configuration for the etcd cluster as a storage backend for
  // the Cluster. This is separated from the apiserver settings, because we
  // plan to separate out etcd from the master nodes.
  //
  // More info: https://etcd.io/docs/latest/
  optional EtcdOpts etcd = 4;

  // ExtraOpts can be used to pass arbitrary key value pairs to be used in
  // bash scripts. For example, if ExtraOpts is set to "FOO=BAR,JANE=BOB",
  // then the following will be defined and available in the phase scripts:
  //   export EXTRA_OPT_FOO=BAR
  //   export EXTRA_OPT_JANE=BOB
  optional string extraOpts = 5;

  // ServicesCIDR contains a CIDR notation IP range from which to assign
  // service cluster IPs. This must not overlap with any IP ranges assigned
  // to nodes or pods.
  optional string servicesCIDR = 6;

  // ContainersCIDR is the range of pods in the cluster. When configured,
  // traffic sent to a Service cluster IP from outside this range will be
  // masqueraded and traffic sent from pods to an external LoadBalancer IP
  // will be directed to the respective cluster IP instead
  optional string containersCIDR = 7;

  // AllowWorkloadsOnMaster signals whether regular workloads are allowed to
  // be run on this Host if it is a master Node.
  optional bool allowWorkloadsOnMaster = 8;

  // KubeletOpts contain Kubelet-specific configuration.
  //
  // See more: https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/
  optional KubeletOpts kubelet = 9;

  // DockerOpts are options for the Docker runtime on the Host.
  optional DockerOpts docker = 10;

  // DockerPrivateRegistry is the location of the docker private registry (if any) that hosts the PF9 container images
  optional string dockerPrivateRegistry = 11;

  // QuayPrivateRegistry is the location of the quay private registry (if any) that hosts the PF9 container images
  optional string quayPrivateRegistry = 12;

  // GCRPrivateRegistry is the location of the gcr private registry (if any) that hosts the PF9 container images
  optional string gcrPrivateRegistry = 13;

  // K8SPrivateRegistry is the location of the k8s private registry (if any) that hosts the PF9 container images
  optional string k8sPrivateRegistry = 14;

  // ContainerRuntime specifies the container runtime to use
  optional string containerRuntime = 15;
}

// HostStatus represents information about the status of a Host. Status may
// trail the actual state of a system, especially if the Host is not able to
// contact Sunpike.
message HostStatus {
  // HostState constains the overall state of this Host.
  optional string hostState = 1;

  // ClusterRole is the role that is currently observed to be installed on
  // the Host.
  optional string clusterRole = 2;

  // ClusterID is the observed ClusterID. This should be equivalent to the
  // ClusterID in the HostSpec, but is also stored in the HostStatus for
  // backward-compatibility.
  optional string clusterID = 3;

  // ServiceState is the current desired state of the Host. This should be
  // equivalent to the KubeServiceState in the HostSpec, but is also stored
  // in the HostStatus for backward-compatibility.
  //
  // If true the Host is being added to the
  // cluster as a Node; if set to false the Host is being removed from the
  // cluster as a Node; and, if set to another value (commonly "" or "ignore")
  // the Host is simply being ignored and left in whatever state it is.
  optional bool serviceState = 4;

  // Hostname contains the hostname of the Host.
  optional string hostname = 5;

  // Nodelet contains information about the current state of the Nodelet
  // process on the Host.
  optional NodeletStatus nodelet = 6;

  // Phases provides details about the progress of the scripts (phases)
  // responsible for bringing the Host into or out of the Cluster. The phases
  // are run in the order they are shown here.
  repeated HostPhase phases = 10;

  // PhaseCompleted specifies the order of the phase until which the chain has
  // been completed successfully so far.
  optional int32 phaseCompleted = 11;

  // LastFailedPhase will be the order of the phase which failed to start in
  // last attempt. If none have failed, this will be -1.
  optional int32 lastFailedPhase = 12;

  // StartAttempts describes the number of times Nodelet has attempted to run
  // the start scripts.
  optional int32 startAttempts = 13;

  // CurrentPhase is the order of the phase which is currently running.
  optional int32 currentPhase = 14;

  // AllStatusChecks will be the list of integer orders of the phases that
  // should be run as part of a status check.
  repeated int32 allStatusChecks = 20;

  // LastFailedCheck will be the order of the phase for which status check failed.
  optional int32 lastFailedCheck = 21;

  // LastFailedCheckTime contains the timestamp at which the last failed
  // status check was performed. The field is formatted as UNIX timestamp.
  optional int64 lastFailedCheckTime = 22;

  // CurrentStatusCheck will be the order of the phase for which status
  // check is running.
  //
  // Note(erwin): with the current reduced status updates, this will always be
  // 				empty. We should consider removing this field.
  optional int32 currentStatusCheck = 23;

  // CurrentStatusCheckTime specifies the timestamp at which the current
  // status check has started. The field is formatted as UNIX timestamp.
  //
  // Note(erwin): with the current reduced status updates, this will always be
  // 				empty. We should consider removing this field.
  optional int64 currentStatusCheckTime = 24;
}

// KeepalivedOpts contains the settings to configure keepalived, which is used
// to handle failovers of a virtual IP in a multi master deployment on bare OS
// cluster.
//
// More info: https://www.keepalived.org/manpage.html
message KeepalivedOpts {
  // Enabled signals whether keepalived should be configured on the cluster.
  optional bool enabled = 1;

  optional string masterVIPInterface = 2;

  // MasterVIPPriority is for electing MASTER, highest priority wins.
  // Note(erwin): seems to be unused.
  optional string masterVIPPriority = 3;

  // MasterVIPRouterID is an arbitrary unique number from 1 to 255 used to
  // differentiate multiple instances of vrrpd running on the same NIC
  // (and hence same socket).
  optional string masterVIPRouterID = 4;
}

// KeystoneOpts is the container for all settings related to authentication with
// the OpenStack Keystone identity service.
// Note(erwin): this does not seem to be used by pf9-kube, so this could be left out.
//
// More info: https://docs.openstack.org/keystone/latest/
message KeystoneOpts {
  // Enabled signals whether Keystone should be used for authentication.
  optional bool enabled = 1;

  // Domain contains the DNS name of the Keystone service.
  optional string domain = 2;

  // AuthURL should contain the base URL to the Keystone service.
  optional string authURL = 3;

  optional string password = 4;

  optional string username = 5;

  optional string projectDomainName = 6;

  optional string projectName = 7;

  optional string region = 8;

  optional string userDomainName = 9;
}

// KubeApiserverOpts contains the settings for the kube-apiserver. The most
// relevant parameters of the kube-apiserver are explicitly defined, all other
// flags should be defined using the ExtraArgs field.
//
// More info: https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver
message KubeApiserverOpts {
  // StorageBackend defines the storage backend for persistence.
  // Options: 'etcd3'
  // This is equivalent to the --storage-backend flag for kube-apiserver.
  optional string storageBackend = 1;

  // Privileged allows this cluster to run privileged containers. This is
  // required for Calico CNI and CSI.
  // This is equivalent to the --allow-privileged flag for kube-apiserver.
  //
  // More info: https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities
  optional bool privileged = 2;

  // Port specifies the HTTPS port on which the kube-apiserver should be
  // served.
  // This is equivalent to the --secure-port flag for kube-apiserver.
  optional int32 port = 3;

  // Authz indicates if authorization should be enabled on the kube-apiserver.
  // This option has been deprecated since authorization has been enabled by
  // default since Kubernetes 1.10. This field is no longer used by scripts.
  optional bool authz = 4;

  // RuntimeConfig is comma-separated list of key=value pairs.
  //
  // Equivalent to the --runtime-config of kube-apiserver.
  optional string runtimeConfig = 5;

  // ExtraArgs is a catch-all for all flags of kube-apiserver that are not
  // present as an explicit field. These flags should be seperated with a ",".
  // For example: --skip-log-headers,--tls-min-version=VersionTLS11
  optional string extraArgs = 6;
}

// KubeClusterOpts contains the cluster-wide configuration. These settings
// include the control plane (apiserver, scheduler, and controller-manager),
// networking (CNI, KubeProxy), and the ingress load-balancing (MetalLB).
message KubeClusterOpts {
  // Scheduler contains the settings for the kube-scheduler. The most
  // relevant parameters of the kube-scheduler are explicitly defined, all other
  // flags should be defined using the ExtraArgs field.
  //
  // More info: https://kubernetes.io/docs/reference/command-line-tools-reference/kube-scheduler
  optional KubeSchedulerOpts scheduler = 1;

  // ControllerManager contains the settings for the kube-controller-manager. The most
  // relevant parameters of the kube-controller-manager are explicitly defined, all other
  // flags should be defined using the ExtraArgs field.
  //
  // More info: https://kubernetes.io/docs/reference/command-line-tools-reference/kube-controller-manager
  optional KubeControllerManagerOpts controllerManager = 2;

  // Apiserver contains the settings for the kube-apiserver. The most
  // relevant parameters of the kube-apiserver are explicitly defined, all other
  // flags should be defined using the ExtraArgs field.
  //
  // More info: https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver
  optional KubeApiserverOpts apiserver = 3;

  // CNI contains the CNI configuration, which includes general options,
  // as well as, CNI-specific settings. The current supported CNI plugins in
  // PMK are Calico, and Flannel, one of which should be non-empty based on
  // the NetworkPlugin field (calico or flannel, respectively).
  //
  // More info: https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/
  optional CNIOpts cni = 4;

  // Addons is an aggregation of all supported addons, which include Luigi,
  // Cluster AutoScaler (CAS), App Catalog, and KubeVirt.
  optional AddonsOpts addons = 5;

  // KubeProxy contains settings for the kube-proxy service, which runs on
  // each node and manages forwarding of traffic addressed to the virtual IP
  // addresses (VIPs) of the cluster’s Kubernetes Service objects to the
  // appropriate backend pods.
  //
  // More info: https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/
  optional KubeProxyOpts kubeproxy = 6;

  // MetalLB specifies the options for the MetalLB addon which provides
  // support for load-balancer services.
  //
  // More info: https://metallb.universe.tf
  optional MetalLBOpts metallb = 7;

  // UseHostname specifies the option for registering the bare OS node using
  // hostname (instead of the IP) in the PF9 managed k8s cluster. This option is only applicable to IPv4 hosts.
  // This option is ignored when deploying clusters on IPv6 enabled hosts.
  optional bool useHostname = 8;
}

// KubeControllerManagerOpts contains the settings for the kube-controller-manager. The most
// relevant parameters of the kube-controller-manager are explicitly defined, all other
// flags should be defined using the ExtraArgs field.
//
// More info: https://kubernetes.io/docs/reference/command-line-tools-reference/kube-controller-manager
message KubeControllerManagerOpts {
  // ExtraArgs is a catch-all for all flags of kube-controller-manager that are not
  // present as an explicit field. These flags should be separated with a ",".
  // For example: --skip-log-headers,--tls-min-version=VersionTLS11
  optional string extraArgs = 1;
}

// KubeProxyOpts contain settings for the kube-proxy service, which runs on each
// node and manages forwarding of traffic addressed to the virtual IP addresses
// (VIPs) of the cluster’s Kubernetes Service objects to the appropriate
// backend pods.
//
// More info: https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/
message KubeProxyOpts {
  // Which proxy mode to use: 'userspace' (older) or 'iptables' (faster) or
  // 'ipvs' or 'kernelspace' (windows). If blank, use the best-available
  // proxy (currently iptables). If the iptables proxy is selected,
  // regardless of how, but the system's kernel or iptables versions are
  // insufficient, this always falls back to the userspace proxy.
  optional string mode = 1;
}

// KubeSchedulerOpts contains the settings for the kube-scheduler. The most
// relevant parameters of the kube-scheduler are explicitly defined, all other
// flags should be defined using the ExtraArgs field.
//
// More info: https://kubernetes.io/docs/reference/command-line-tools-reference/kube-scheduler
message KubeSchedulerOpts {
  // ExtraArgs is a catch-all for all flags of kube-scheduler that are not
  // present as an explicit field. These flags should be separated with a ",".
  // For example: --skip-log-headers,--tls-min-version=VersionTLS11
  optional string extraArgs = 1;
}

// KubeVirtOpts contain configuration for the KubeVirt addon.
message KubeVirtOpts {
  // Enabled signals that KubeVirt should be installed on the cluster, if set.
  optional bool enabled = 1;
}

// KubeletOpts contain Kubelet-specific configuration.
//
// See more: https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/
message KubeletOpts {
  // CloudCfg contains the configuration data that will be used in the
  // --cloud-config flag of kubelet. Empty string for no configuration data.
  //
  // (DEPRECATED: will be removed in 1.23, in favor of removing cloud
  // providers code from Kubelet.)
  optional string cloudCfg = 1;
}

// LuigiOpts contain configuration for the Luigi addon.
message LuigiOpts {
  // Enabled signals that Luigi should be installed on the cluster, if set.
  optional bool enabled = 1;
}

// MetalLBOpts are the options for the MetalLB addon which provides support for
// load-balancer services.
//
// More info: https://metallb.universe.tf
message MetalLBOpts {
  // CIDR contains the address range to give MetalLB control over. These will
  // be assigned to services with the type LoadBalancer.
  //
  // Examples: 192.168.1.240-192.168.1.250 or 10.21.0.0/22
  optional string CIDR = 1;

  // Enabled signals that the addon should be installed on the cluster, if set.
  optional bool enabled = 2;
}

// NodeletStatus contains information about the Nodelet process
// itself (rather than about the Host).
message NodeletStatus {
  // Version is the version of Nodelet that is running on the Host.
  optional string version = 1;
}

// PF9Opts contains miscellaneous configuration, mostly related to PF9 services.
message PF9Opts {
  // VaultToken is the token used to generate the certificates with for the
  // cluster.
  optional string vaultToken = 1;

  // Masterless, if set, instructs the cluster to run a proxy to a remote
  // apiserver, rather than running the apiserver in-cluster.
  optional bool masterless = 2;

  // BouncerSlowReqWebhook is a field to enable code instrumentation to be
  // able to detect keystone slowness in some environments. It is unclear
  // whether this is still used.
  //
  // More info: https://platform9.atlassian.net/browse/INF-764
  optional string bouncerSlowReqWebhook = 3;

  // CloudProviderType contains the cloud provider that should be used to
  // provision and bootstrap this Host with. For example, based on the value
  // of this field, the manifests used to bootstrap the control plane are
  // chosen.
  //
  // Options: aws|azure|local|openstack
  optional string cloudProviderType = 4;

  // ClusterID specifies the ID of the Cluster that this Host belongs to.
  optional string clusterID = 5;

  // ClusterProjectID specifies the ID of the project that the Cluster and
  // thereby this Host belong too.
  optional string clusterProjectID = 6;

  // Debug will increase the verbosity of logging if set.
  optional bool debug = 7;

  // KubeServiceState is the desired state of this Host in relation to
  // the target cluster. If set to "true" the Host should be added to the
  // cluster as a Node; if set to "false" the Host should be removed from the
  // cluster as a Node; and, if set to another value (commonly "" or "ignore")
  // the Host should simply be ignored and left in whatever state it is.
  optional string kubeServiceState = 8;

  // ExternalDNSName specifies the externally-accessible DNS name for the
  // control plane of the cluster.
  optional string externalDNSName = 9;

  // ClusterRole specifies the role that this Host should take within the
  // cluster. Options:
  // - master:	turn the host into a Kubernetes master node.
  // - worker:	turn the host into a Kubernetes worker node.
  // - none:		do not turn the host into a Kubernetes node.
  optional string clusterRole = 10;

  optional KeepalivedOpts keepalived = 11;

  // Keystone is the container for all settings related to authentication with
  // the OpenStack Keystone identity service.
  //
  // More info: https://docs.openstack.org/keystone/latest/
  optional KeystoneOpts keystone = 12;

  // MasterIP either contains a FDQN (in case of a public cloud), or the
  // primary IP of the master node (in case of a single master), or the
  // primary IP of the last added master node (in case of multi-master
  // without keepalived) or the Virtual IP (if keepalived is enabled).
  optional string masterIP = 13;
}

// ProfileAgentOpts contains configuration related to platform9 profile engine agent
message ProfileAgentOpts {
  // Enabled signals that profile agent should be installed on the cluster, if set.
  optional bool enabled = 1;
}

